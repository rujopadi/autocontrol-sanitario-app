#!/usr/bin/env node

/**
 * Comprehensive Test Runner
 * Executes all test suites and generates detailed reports
 */

const { spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');

class TestRunner {
  constructor() {
    this.results = {
      unit: { passed: 0, failed: 0, duration: 0, coverage: 0 },
      integration: { passed: 0, failed: 0, duration: 0 },
      e2e: { passed: 0, failed: 0, duration: 0 },
      security: { passed: 0, failed: 0, duration: 0 },
      performance: { passed: 0, failed: 0, duration: 0 },
      overall: { passed: 0, failed: 0, duration: 0 }
    };
    this.startTime = Date.now();
  }

  async runCommand(command, args, options = {}) {
    return new Promise((resolve, reject) => {
      console.log(`\\n🚀 Running: ${command} ${args.join(' ')}`);\n      
      const process = spawn(command, args, {\n        stdio: 'pipe',\n        shell: true,\n        ...options\n      });\n\n      let stdout = '';\n      let stderr = '';\n\n      process.stdout.on('data', (data) => {\n        const output = data.toString();\n        stdout += output;\n        console.log(output);\n      });\n\n      process.stderr.on('data', (data) => {\n        const output = data.toString();\n        stderr += output;\n        console.error(output);\n      });\n\n      process.on('close', (code) => {\n        resolve({ code, stdout, stderr });\n      });\n\n      process.on('error', (error) => {\n        reject(error);\n      });\n    });\n  }\n\n  parseJestOutput(output) {\n    const lines = output.split('\\n');\n    let passed = 0;\n    let failed = 0;\n    let duration = 0;\n    let coverage = 0;\n\n    for (const line of lines) {\n      // Parse test results\n      if (line.includes('Tests:')) {\n        const match = line.match(/(\\d+) passed/);\n        if (match) passed = parseInt(match[1]);\n        \n        const failMatch = line.match(/(\\d+) failed/);\n        if (failMatch) failed = parseInt(failMatch[1]);\n      }\n      \n      // Parse duration\n      if (line.includes('Time:')) {\n        const match = line.match(/Time:\\s*([\\d.]+)s/);\n        if (match) duration = parseFloat(match[1]) * 1000;\n      }\n      \n      // Parse coverage\n      if (line.includes('All files')) {\n        const match = line.match(/(\\d+\\.\\d+)%/);\n        if (match) coverage = parseFloat(match[1]);\n      }\n    }\n\n    return { passed, failed, duration, coverage };\n  }\n\n  async runUnitTests() {\n    console.log('\\n📋 Running Unit Tests...');\n    const startTime = Date.now();\n    \n    try {\n      const result = await this.runCommand('npm', ['run', 'test:unit', '--', '--coverage', '--verbose']);\n      const parsed = this.parseJestOutput(result.stdout);\n      \n      this.results.unit = {\n        ...parsed,\n        duration: Date.now() - startTime,\n        success: result.code === 0\n      };\n      \n      console.log(`✅ Unit Tests: ${parsed.passed} passed, ${parsed.failed} failed`);\n    } catch (error) {\n      console.error('❌ Unit Tests failed:', error.message);\n      this.results.unit.success = false;\n    }\n  }\n\n  async runIntegrationTests() {\n    console.log('\\n🔗 Running Integration Tests...');\n    const startTime = Date.now();\n    \n    try {\n      const result = await this.runCommand('npm', ['run', 'test:integration', '--', '--verbose']);\n      const parsed = this.parseJestOutput(result.stdout);\n      \n      this.results.integration = {\n        ...parsed,\n        duration: Date.now() - startTime,\n        success: result.code === 0\n      };\n      \n      console.log(`✅ Integration Tests: ${parsed.passed} passed, ${parsed.failed} failed`);\n    } catch (error) {\n      console.error('❌ Integration Tests failed:', error.message);\n      this.results.integration.success = false;\n    }\n  }\n\n  async runE2ETests() {\n    console.log('\\n🎭 Running End-to-End Tests...');\n    const startTime = Date.now();\n    \n    try {\n      const result = await this.runCommand('npm', ['run', 'test:e2e', '--', '--verbose']);\n      const parsed = this.parseJestOutput(result.stdout);\n      \n      this.results.e2e = {\n        ...parsed,\n        duration: Date.now() - startTime,\n        success: result.code === 0\n      };\n      \n      console.log(`✅ E2E Tests: ${parsed.passed} passed, ${parsed.failed} failed`);\n    } catch (error) {\n      console.error('❌ E2E Tests failed:', error.message);\n      this.results.e2e.success = false;\n    }\n  }\n\n  async runSecurityTests() {\n    console.log('\\n🔒 Running Security Tests...');\n    const startTime = Date.now();\n    \n    try {\n      const result = await this.runCommand('npm', ['run', 'test:security', '--', '--verbose']);\n      const parsed = this.parseJestOutput(result.stdout);\n      \n      this.results.security = {\n        ...parsed,\n        duration: Date.now() - startTime,\n        success: result.code === 0\n      };\n      \n      console.log(`✅ Security Tests: ${parsed.passed} passed, ${parsed.failed} failed`);\n    } catch (error) {\n      console.error('❌ Security Tests failed:', error.message);\n      this.results.security.success = false;\n    }\n  }\n\n  async runPerformanceTests() {\n    console.log('\\n⚡ Running Performance Tests...');\n    const startTime = Date.now();\n    \n    try {\n      const result = await this.runCommand('npm', ['run', 'test:performance', '--', '--verbose']);\n      const parsed = this.parseJestOutput(result.stdout);\n      \n      this.results.performance = {\n        ...parsed,\n        duration: Date.now() - startTime,\n        success: result.code === 0\n      };\n      \n      console.log(`✅ Performance Tests: ${parsed.passed} passed, ${parsed.failed} failed`);\n    } catch (error) {\n      console.error('❌ Performance Tests failed:', error.message);\n      this.results.performance.success = false;\n    }\n  }\n\n  calculateOverallResults() {\n    const categories = ['unit', 'integration', 'e2e', 'security', 'performance'];\n    \n    this.results.overall = {\n      passed: categories.reduce((sum, cat) => sum + this.results[cat].passed, 0),\n      failed: categories.reduce((sum, cat) => sum + this.results[cat].failed, 0),\n      duration: Date.now() - this.startTime,\n      success: categories.every(cat => this.results[cat].success !== false)\n    };\n  }\n\n  generateReport() {\n    const report = {\n      timestamp: new Date().toISOString(),\n      environment: {\n        node: process.version,\n        platform: process.platform,\n        arch: process.arch\n      },\n      results: this.results,\n      summary: {\n        totalTests: this.results.overall.passed + this.results.overall.failed,\n        passRate: this.results.overall.passed / (this.results.overall.passed + this.results.overall.failed) * 100,\n        duration: this.results.overall.duration,\n        success: this.results.overall.success\n      }\n    };\n\n    return report;\n  }\n\n  async saveReport(report) {\n    const reportsDir = path.join(__dirname, '../test-reports');\n    \n    try {\n      await fs.mkdir(reportsDir, { recursive: true });\n    } catch (error) {\n      // Directory might already exist\n    }\n\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const reportPath = path.join(reportsDir, `test-report-${timestamp}.json`);\n    \n    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\n    \n    // Also save as latest report\n    const latestPath = path.join(reportsDir, 'latest-test-report.json');\n    await fs.writeFile(latestPath, JSON.stringify(report, null, 2));\n    \n    return reportPath;\n  }\n\n  printSummary(report) {\n    console.log('\\n' + '='.repeat(80));\n    console.log('🎯 COMPREHENSIVE TEST RESULTS SUMMARY');\n    console.log('='.repeat(80));\n    \n    console.log(`\\n📊 Overall Results:`);\n    console.log(`   Total Tests: ${report.summary.totalTests}`);\n    console.log(`   Passed: ${report.results.overall.passed} (${report.summary.passRate.toFixed(1)}%)`);\n    console.log(`   Failed: ${report.results.overall.failed}`);\n    console.log(`   Duration: ${(report.summary.duration / 1000).toFixed(2)}s`);\n    console.log(`   Status: ${report.summary.success ? '✅ SUCCESS' : '❌ FAILED'}`);\n    \n    console.log(`\\n📋 Test Categories:`);\n    const categories = [\n      { name: 'Unit Tests', key: 'unit', icon: '🧪' },\n      { name: 'Integration Tests', key: 'integration', icon: '🔗' },\n      { name: 'End-to-End Tests', key: 'e2e', icon: '🎭' },\n      { name: 'Security Tests', key: 'security', icon: '🔒' },\n      { name: 'Performance Tests', key: 'performance', icon: '⚡' }\n    ];\n    \n    categories.forEach(cat => {\n      const result = report.results[cat.key];\n      const status = result.success !== false ? '✅' : '❌';\n      const duration = (result.duration / 1000).toFixed(2);\n      console.log(`   ${cat.icon} ${cat.name}: ${result.passed} passed, ${result.failed} failed (${duration}s) ${status}`);\n    });\n    \n    if (report.results.unit.coverage > 0) {\n      console.log(`\\n📈 Code Coverage: ${report.results.unit.coverage.toFixed(1)}%`);\n    }\n    \n    console.log('\\n' + '='.repeat(80));\n    \n    if (!report.summary.success) {\n      console.log('\\n❌ Some tests failed. Please review the output above for details.');\n      process.exit(1);\n    } else {\n      console.log('\\n🎉 All tests passed successfully!');\n    }\n  }\n\n  async run() {\n    console.log('🚀 Starting Comprehensive Test Suite...');\n    console.log(`📅 Started at: ${new Date().toISOString()}`);\n    \n    // Run all test suites\n    await this.runUnitTests();\n    await this.runIntegrationTests();\n    await this.runE2ETests();\n    await this.runSecurityTests();\n    await this.runPerformanceTests();\n    \n    // Calculate overall results\n    this.calculateOverallResults();\n    \n    // Generate and save report\n    const report = this.generateReport();\n    const reportPath = await this.saveReport(report);\n    \n    console.log(`\\n📄 Test report saved to: ${reportPath}`);\n    \n    // Print summary\n    this.printSummary(report);\n  }\n}\n\n// Run if called directly\nif (require.main === module) {\n  const runner = new TestRunner();\n  runner.run().catch(error => {\n    console.error('❌ Test runner failed:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = TestRunner;